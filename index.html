<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>Mobile Gesture Carousel Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000;
            color: #fff;
            overflow-x: hidden;
            overflow-y: hidden;
            height: 100vh;
            height: 100dvh; /* Dynamic viewport height per mobile */
            max-height: 100vh;
            max-height: 100dvh;
            display: flex;
            flex-direction: column;
            position: fixed;
            width: 100%;
            top: 0;
            left: 0;
        }

        .carousel-container {
            flex: 1;
            min-height: 0;
            overflow-x: auto;
            overflow-y: hidden;
            scroll-snap-type: x mandatory;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
            display: flex;
            position: relative;
            touch-action: pan-y pinch-zoom; /* Permette solo scroll verticale e pinch zoom */
        }

        .carousel-wrapper {
            display: flex;
            min-width: 100%;
            height: 100%;
        }

        .carousel-item {
            min-width: 100vw;
            width: 100vw;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            scroll-snap-align: start;
            position: relative;
        }

        .carousel-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        .carousel-item-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .gesture-area {
            height: 150px;
            min-height: 150px;
            max-height: 150px;
            background: rgba(255, 255, 255, 0.1);
            border-top: 2px solid rgba(255, 255, 255, 0.3);
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            padding-bottom: env(safe-area-inset-bottom);
        }

        .gesture-indicator {
            width: 60px;
            height: 60px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .gesture-indicator.active {
            border-color: #4CAF50;
            background: rgba(76, 175, 80, 0.2);
            transform: scale(1.1);
        }

        .gesture-indicator::before {
            content: '↻';
            font-size: 24px;
            color: rgba(255, 255, 255, 0.7);
        }

        .gesture-indicator.active::before {
            color: #4CAF50;
        }

        .gesture-path {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .gesture-path.active {
            opacity: 0.6;
        }

        .debug-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 1000;
            display: none;
        }

        .debug-info.active {
            display: block;
        }

        .pull-to-refresh {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.8);
            transform: translateY(-100%);
            transition: transform 0.3s ease, opacity 0.3s ease;
            z-index: 2000;
            pointer-events: none;
            opacity: 0;
        }

        .pull-to-refresh.active {
            transform: translateY(0);
            opacity: 1;
        }

        .pull-to-refresh-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            color: #fff;
            font-size: 14px;
        }

        .pull-to-refresh-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: #fff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .pull-to-refresh.active .pull-to-refresh-spinner {
            display: block;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @media (min-width: 768px) {
            body::before {
                content: 'Questa pagina è ottimizzata solo per dispositivi mobili';
                display: flex;
                align-items: center;
                justify-content: center;
                height: 100vh;
                font-size: 24px;
                text-align: center;
                padding: 20px;
            }
            
            .carousel-container,
            .gesture-area {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="pull-to-refresh" id="pullToRefresh">
        <div class="pull-to-refresh-indicator">
            <div class="pull-to-refresh-spinner"></div>
            <span>Rilascia per ricaricare</span>
        </div>
    </div>

    <div class="debug-info" id="debugInfo">
        <div>Stato: <span id="gestureStatus">Inattivo</span></div>
        <div>Punti: <span id="pointCount">0</span></div>
        <div>Angolo: <span id="angle">0°</span></div>
        <div>Direzione: <span id="direction">-</span></div>
    </div>

    <div class="carousel-container" id="carousel">
        <div class="carousel-wrapper">
            <div class="carousel-item">
                <div class="carousel-item-placeholder" style="background: linear-gradient(135deg, #FF6B6B 0%, #EE5A6F 100%);">
                    <span>Immagine 1</span>
                </div>
            </div>
            <div class="carousel-item">
                <div class="carousel-item-placeholder" style="background: linear-gradient(135deg, #4ECDC4 0%, #44A08D 100%);">
                    <span>Immagine 2</span>
                </div>
            </div>
            <div class="carousel-item">
                <div class="carousel-item-placeholder" style="background: linear-gradient(135deg, #95E1D3 0%, #7EC8E3 100%);">
                    <span>Immagine 3</span>
                </div>
            </div>
            <div class="carousel-item">
                <div class="carousel-item-placeholder" style="background: linear-gradient(135deg, #F38181 0%, #EA8D8D 100%);">
                    <span>Immagine 4</span>
                </div>
            </div>
            <div class="carousel-item">
                <div class="carousel-item-placeholder" style="background: linear-gradient(135deg, #AA96DA 0%, #C2B5E3 100%);">
                    <span>Immagine 5</span>
                </div>
            </div>
        </div>
    </div>

    <div class="gesture-area" id="gestureArea">
        <div class="gesture-indicator" id="gestureIndicator"></div>
        <svg class="gesture-path" id="gesturePath" width="100%" height="100%">
            <path id="pathElement" stroke="#4CAF50" stroke-width="2" fill="none" />
        </svg>
    </div>

    <script>
        class CircularGestureDetector {
            constructor(gestureArea, carousel) {
                this.gestureArea = gestureArea;
                this.carousel = carousel;
                this.touchPoints = [];
                this.isTracking = false;
                this.minRadius = 20;
                this.maxRadius = 150;
                this.minPoints = 5;
                this.center = { x: 0, y: 0 };
                this.pathElement = document.getElementById('pathElement');
                this.gestureIndicator = document.getElementById('gestureIndicator');
                this.debugInfo = document.getElementById('debugInfo');
                this.lastScrollTime = 0;
                this.scrollThrottle = 300; // Millisecondi tra uno scroll e l'altro
                this.lastAngle = null;
                this.accumulatedAngle = 0;
                this.accumulatedAngleCounterClockwise = 0;
                this.carouselTouchStartX = null;
                this.carouselTouchStartY = null;
                this.browserSwipeStartX = null;
                this.browserSwipeStartY = null;
                this.browserSwipeStartTime = null;
                this.pullToRefresh = document.getElementById('pullToRefresh');
                this.pullStartY = null;
                this.pullCurrentY = null;
                this.pullThreshold = 80; // Pixel da tirare per attivare il refresh
                this.isPulling = false;
                
                this.init();
            }

            init() {
                this.gestureArea.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                this.gestureArea.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                this.gestureArea.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
                
                // Blocca lo swipe orizzontale nativo sul carosello
                this.carousel.addEventListener('touchmove', this.preventCarouselSwipe.bind(this), { passive: false });
                this.carousel.addEventListener('touchstart', this.handleCarouselTouchStart.bind(this), { passive: false });
                this.carousel.addEventListener('touchend', this.handleCarouselTouchEnd.bind(this), { passive: false });
                
                // Blocca lo swipe laterale del browser per navigazione indietro
                document.addEventListener('touchstart', this.preventBrowserSwipeStart.bind(this), { passive: false });
                document.addEventListener('touchmove', this.preventBrowserSwipeMove.bind(this), { passive: false });
                document.addEventListener('touchend', this.preventBrowserSwipeEnd.bind(this), { passive: false });
                
                // Pull-to-refresh: rileva scroll verso il basso
                document.addEventListener('touchstart', this.handlePullStart.bind(this), { passive: false });
                document.addEventListener('touchmove', this.handlePullMove.bind(this), { passive: false });
                document.addEventListener('touchend', this.handlePullEnd.bind(this), { passive: false });
                
                // Calcola il centro dell'area di gesto
                const rect = this.gestureArea.getBoundingClientRect();
                this.center = {
                    x: rect.left + rect.width / 2,
                    y: rect.top + rect.height / 2
                };

                // Debug mode: double tap per attivare/disattivare
                this.gestureArea.addEventListener('dblclick', () => {
                    this.debugInfo.classList.toggle('active');
                });
            }

            handleCarouselTouchStart(e) {
                // Memorizza la posizione iniziale del tocco
                this.carouselTouchStartX = e.touches[0].clientX;
                this.carouselTouchStartY = e.touches[0].clientY;
            }

            preventCarouselSwipe(e) {
                // Blocca sempre lo swipe orizzontale sul carosello
                // Lo scroll sarà controllato solo tramite la gesture circolare
                if (!this.carouselTouchStartX || !this.carouselTouchStartY) return;
                
                const touch = e.touches[0];
                const deltaX = Math.abs(touch.clientX - this.carouselTouchStartX);
                const deltaY = Math.abs(touch.clientY - this.carouselTouchStartY);
                
                // Blocca se il movimento è principalmente orizzontale (più di 10px e più orizzontale che verticale)
                if (deltaX > 10 && deltaX > deltaY) {
                    e.preventDefault();
                    e.stopPropagation();
                }
            }

            handleCarouselTouchEnd(e) {
                // Reset delle variabili quando il tocco finisce
                this.carouselTouchStartX = null;
                this.carouselTouchStartY = null;
            }

            preventBrowserSwipeStart(e) {
                // Traccia l'inizio del tocco per rilevare swipe laterali
                const touch = e.touches[0];
                this.browserSwipeStartX = touch.clientX;
                this.browserSwipeStartY = touch.clientY;
                this.browserSwipeStartTime = Date.now();
            }

            preventBrowserSwipeMove(e) {
                // Se il tocco è nell'area di gesto, non bloccare (gestito da handleTouchMove)
                const touch = e.touches[0];
                const rect = this.gestureArea.getBoundingClientRect();
                const touchX = touch.clientX;
                const touchY = touch.clientY;
                
                // Se il tocco è nell'area di gesto, lascia gestire a quella funzione
                if (touchX >= rect.left && touchX <= rect.right && 
                    touchY >= rect.top && touchY <= rect.bottom) {
                    return;
                }
                
                // Se il tocco è sul carosello, lascia gestire a quella funzione
                const carouselRect = this.carousel.getBoundingClientRect();
                if (touchX >= carouselRect.left && touchX <= carouselRect.right && 
                    touchY >= carouselRect.top && touchY <= carouselRect.bottom) {
                    return;
                }
                
                // Blocca gli swipe laterali che partono dall'edge dello schermo
                if (this.browserSwipeStartX !== null && this.browserSwipeStartY !== null) {
                    const deltaX = touch.clientX - this.browserSwipeStartX;
                    const deltaY = touch.clientY - this.browserSwipeStartY;
                    const absDeltaX = Math.abs(deltaX);
                    const absDeltaY = Math.abs(deltaY);
                    
                    // Permetti pull-to-refresh: movimento verticale verso il basso nella parte superiore
                    if (this.browserSwipeStartY < 50 && deltaY > 0 && absDeltaY > absDeltaX) {
                        return; // Non bloccare il pull-to-refresh
                    }
                    
                    // Blocca se:
                    // 1. Il movimento è principalmente orizzontale
                    // 2. Parte dall'edge sinistro (primi 20px) o destro (ultimi 20px)
                    // 3. Il movimento supera i 10px
                    const screenWidth = window.innerWidth;
                    const isLeftEdge = this.browserSwipeStartX < 20;
                    const isRightEdge = this.browserSwipeStartX > screenWidth - 20;
                    
                    if ((isLeftEdge || isRightEdge) && absDeltaX > 10 && absDeltaX > absDeltaY) {
                        e.preventDefault();
                        e.stopPropagation();
                        return false;
                    }
                    
                    // Blocca anche swipe orizzontali generali che non sono nell'area di gesto o carosello
                    if (absDeltaX > 30 && absDeltaX > absDeltaY * 1.5) {
                        e.preventDefault();
                        e.stopPropagation();
                        return false;
                    }
                }
            }

            preventBrowserSwipeEnd(e) {
                // Reset delle variabili quando il tocco finisce
                this.browserSwipeStartX = null;
                this.browserSwipeStartY = null;
                this.browserSwipeStartTime = null;
            }

            handlePullStart(e) {
                // Verifica se il tocco inizia nella parte superiore dello schermo
                const touch = e.touches[0];
                const startY = touch.clientY;
                const startX = touch.clientX;
                
                // Se il tocco inizia nella parte superiore dello schermo (primi 50px)
                // e non è nell'area di gesto o nel carosello, attiva il pull-to-refresh
                if (startY < 50) {
                    const rect = this.gestureArea.getBoundingClientRect();
                    const carouselRect = this.carousel.getBoundingClientRect();
                    
                    // Verifica che non sia nell'area di gesto o nel carosello
                    if (!(startX >= rect.left && startX <= rect.right && startY >= rect.top && startY <= rect.bottom) &&
                        !(startX >= carouselRect.left && startX <= carouselRect.right && startY >= carouselRect.top && startY <= carouselRect.bottom)) {
                        this.pullStartY = startY;
                        this.isPulling = false;
                    }
                }
            }

            handlePullMove(e) {
                if (this.pullStartY === null) return;
                
                const touch = e.touches[0];
                const currentY = touch.clientY;
                const deltaY = currentY - this.pullStartY;
                
                // Se stiamo tirando verso il basso (deltaY positivo)
                // Verifica che il carosello sia all'inizio dello scroll
                if (deltaY > 0 && this.carousel.scrollLeft === 0) {
                    // Previeni lo scroll normale
                    e.preventDefault();
                    
                    // Se superiamo la soglia minima, mostra l'indicatore
                    if (deltaY > 20) {
                        this.isPulling = true;
                        const pullDistance = Math.min(deltaY, this.pullThreshold * 1.5);
                        const opacity = Math.min(pullDistance / this.pullThreshold, 1);
                        
                        // Mostra l'indicatore con animazione
                        this.pullToRefresh.style.transform = `translateY(${Math.min(pullDistance - 60, 0)}px)`;
                        this.pullToRefresh.style.opacity = opacity;
                        
                        if (pullDistance >= this.pullThreshold) {
                            this.pullToRefresh.classList.add('active');
                            this.pullToRefresh.querySelector('span').textContent = 'Rilascia per ricaricare';
                        } else {
                            this.pullToRefresh.classList.remove('active');
                            this.pullToRefresh.querySelector('span').textContent = 'Tira per ricaricare';
                        }
                    }
                } else {
                    // Reset se non stiamo tirando verso il basso o il carosello non è all'inizio
                    this.resetPullToRefresh();
                }
            }

            handlePullEnd(e) {
                if (this.pullStartY === null) return;
                
                const touch = e.changedTouches[0];
                const currentY = touch.clientY;
                const deltaY = currentY - this.pullStartY;
                
                // Se abbiamo tirato abbastanza, ricarica la pagina
                if (this.isPulling && deltaY >= this.pullThreshold) {
                    this.pullToRefresh.classList.add('active');
                    this.pullToRefresh.querySelector('span').textContent = 'Ricaricamento...';
                    
                    // Ricarica la pagina dopo un breve delay per mostrare l'animazione
                    setTimeout(() => {
                        window.location.reload();
                    }, 300);
                } else {
                    // Altrimenti, nascondi l'indicatore
                    this.resetPullToRefresh();
                }
                
                this.pullStartY = null;
                this.isPulling = false;
            }

            resetPullToRefresh() {
                this.pullToRefresh.style.transform = 'translateY(-100%)';
                this.pullToRefresh.style.opacity = '0';
                this.pullToRefresh.classList.remove('active');
            }

            handleTouchStart(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = this.gestureArea.getBoundingClientRect();
                const touchX = touch.clientX;
                const touchY = touch.clientY;

                // Verifica che il tocco sia nell'area di gesto
                if (touchX >= rect.left && touchX <= rect.right && 
                    touchY >= rect.top && touchY <= rect.bottom) {
                    this.isTracking = true;
                    this.touchPoints = [];
                    this.accumulatedAngle = 0;
                    this.accumulatedAngleCounterClockwise = 0;
                    this.lastAngle = null;
                    this.lastScrollTime = 0;
                    this.center = {
                        x: rect.left + rect.width / 2,
                        y: rect.top + rect.height / 2
                    };
                    this.addTouchPoint(touchX, touchY);
                    this.gestureIndicator.classList.add('active');
                    this.updateDebugInfo('Tracciamento...', this.touchPoints.length);
                }
            }

            handleTouchMove(e) {
                if (!this.isTracking) return;
                e.preventDefault();
                const touch = e.touches[0];
                this.addTouchPoint(touch.clientX, touch.clientY);
                this.updatePath();
                
                // Rileva movimento circolare in tempo reale
                if (this.touchPoints.length >= 2) {
                    this.detectContinuousGesture();
                }
                
                this.updateDebugInfo('Tracciamento...', this.touchPoints.length);
            }

            handleTouchEnd(e) {
                if (!this.isTracking) return;
                e.preventDefault();
                
                this.isTracking = false;
                this.touchPoints = [];
                this.accumulatedAngle = 0;
                this.accumulatedAngleCounterClockwise = 0;
                this.lastAngle = null;
                this.gestureIndicator.classList.remove('active');
                this.pathElement.setAttribute('d', '');
                this.pathElement.classList.remove('active');
                
                setTimeout(() => {
                    this.updateDebugInfo('Inattivo', 0);
                }, 2000);
            }

            addTouchPoint(x, y) {
                const relativeX = x - this.center.x;
                const relativeY = y - this.center.y;
                const distance = Math.sqrt(relativeX * relativeX + relativeY * relativeY);
                
                // Accetta tutti i punti, ma salva la distanza per il calcolo successivo
                // Non filtriamo più strettamente, lasciamo che l'algoritmo valuti
                this.touchPoints.push({
                    x: x,
                    y: y,
                    relativeX: relativeX,
                    relativeY: relativeY,
                    distance: distance,
                    angle: Math.atan2(relativeY, relativeX)
                });
            }

            updatePath() {
                if (this.touchPoints.length < 2) return;
                
                const pathData = this.touchPoints.map((point, index) => {
                    const relativeX = point.x - this.gestureArea.getBoundingClientRect().left;
                    const relativeY = point.y - this.gestureArea.getBoundingClientRect().top;
                    return `${index === 0 ? 'M' : 'L'} ${relativeX} ${relativeY}`;
                }).join(' ');
                
                this.pathElement.setAttribute('d', pathData);
                this.pathElement.classList.add('active');
            }

            detectContinuousGesture() {
                if (this.touchPoints.length < 2) return;
                
                const now = Date.now();
                const lastPoint = this.touchPoints[this.touchPoints.length - 1];
                
                // Calcola l'angolo rispetto al centro dell'area di gesto
                const dx = lastPoint.x - this.center.x;
                const dy = lastPoint.y - this.center.y;
                const currentAngle = Math.atan2(dy, dx);
                
                // Se abbiamo un angolo precedente, calcola la differenza
                if (this.lastAngle !== null) {
                    let angleDiff = currentAngle - this.lastAngle;
                    
                    // Normalizza l'angolo per gestire il passaggio da -π a π
                    if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    
                    // Gestisci movimento orario (forward)
                    if (angleDiff > 0) {
                        this.accumulatedAngle += angleDiff;
                        // Reset dell'accumulatore antiorario quando cambia direzione
                        this.accumulatedAngleCounterClockwise = Math.max(0, this.accumulatedAngleCounterClockwise - Math.abs(angleDiff) * 0.5);
                        
                        // Quando accumuliamo almeno π/4 (45 gradi), scrolliamo avanti
                        if (this.accumulatedAngle >= Math.PI / 4) {
                            const timeSinceLastScroll = now - this.lastScrollTime;
                            if (timeSinceLastScroll >= this.scrollThrottle) {
                                this.triggerCarouselScroll('forward');
                                this.accumulatedAngle = 0; // Reset dopo lo scroll
                                this.lastScrollTime = now;
                            }
                        }
                    } else if (angleDiff < 0) {
                        // Movimento antiorario (backward)
                        this.accumulatedAngleCounterClockwise += Math.abs(angleDiff);
                        // Reset dell'accumulatore orario quando cambia direzione
                        this.accumulatedAngle = Math.max(0, this.accumulatedAngle - Math.abs(angleDiff) * 0.5);
                        
                        // Quando accumuliamo almeno π/4 (45 gradi), scrolliamo indietro
                        if (this.accumulatedAngleCounterClockwise >= Math.PI / 4) {
                            const timeSinceLastScroll = now - this.lastScrollTime;
                            if (timeSinceLastScroll >= this.scrollThrottle) {
                                this.triggerCarouselScroll('backward');
                                this.accumulatedAngleCounterClockwise = 0; // Reset dopo lo scroll
                                this.lastScrollTime = now;
                            }
                        }
                    }
                }
                
                this.lastAngle = currentAngle;
            }

            detectCircularGesture() {
                if (this.touchPoints.length < this.minPoints) return false;

                // Calcola il centro medio del movimento
                const avgX = this.touchPoints.reduce((sum, p) => sum + p.x, 0) / this.touchPoints.length;
                const avgY = this.touchPoints.reduce((sum, p) => sum + p.y, 0) / this.touchPoints.length;
                
                // Ricalcola angoli relativi al centro medio
                const pointsWithAngles = this.touchPoints.map(p => {
                    const dx = p.x - avgX;
                    const dy = p.y - avgY;
                    return {
                        angle: Math.atan2(dy, dx),
                        distance: Math.sqrt(dx * dx + dy * dy)
                    };
                });

                // Calcola la varianza del raggio per verificare che sia circolare
                const avgRadius = pointsWithAngles.reduce((sum, p) => sum + p.distance, 0) / pointsWithAngles.length;
                if (avgRadius < this.minRadius) return false; // Troppo vicino al centro
                
                const radiusVariance = pointsWithAngles.reduce((sum, p) => {
                    const diff = p.distance - avgRadius;
                    return sum + diff * diff;
                }, 0) / pointsWithAngles.length;
                const radiusStdDev = Math.sqrt(radiusVariance);
                const radiusConsistent = radiusStdDev < avgRadius * 0.5; // Più tollerante (50%)

                // Calcola l'angolo totale percorso
                let totalAngle = 0;
                for (let i = 1; i < pointsWithAngles.length; i++) {
                    let angleDiff = pointsWithAngles[i].angle - pointsWithAngles[i - 1].angle;
                    // Normalizza l'angolo per gestire il passaggio da -π a π
                    if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    totalAngle += angleDiff;
                }

                // Per un cerchio orario, l'angolo totale dovrebbe essere positivo e almeno π (mezzo cerchio)
                const isCompleteCircle = Math.abs(totalAngle) >= Math.PI; // Almeno mezzo cerchio
                const isClockwise = totalAngle > 0; // Movimento orario = angolo positivo

                // Verifica la consistenza della direzione
                let clockwiseCount = 0;
                let counterClockwiseCount = 0;
                for (let i = 1; i < pointsWithAngles.length; i++) {
                    let angleDiff = pointsWithAngles[i].angle - pointsWithAngles[i - 1].angle;
                    if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                    if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                    if (angleDiff > 0.1) clockwiseCount++; // Piccola soglia per evitare rumore
                    if (angleDiff < -0.1) counterClockwiseCount++;
                }
                
                // Per movimento orario, la maggior parte dei cambiamenti deve essere oraria
                const directionConsistent = isClockwise ? clockwiseCount > counterClockwiseCount * 1.2 : 
                                                          counterClockwiseCount > clockwiseCount * 1.2;
                
                return radiusConsistent && isCompleteCircle && isClockwise && directionConsistent;
            }

            triggerCarouselScroll(direction = 'forward') {
                const scrollAmount = this.carousel.clientWidth;
                const currentScroll = this.carousel.scrollLeft;
                const maxScroll = this.carousel.scrollWidth - this.carousel.clientWidth;
                
                let nextScroll;
                if (direction === 'forward') {
                    nextScroll = currentScroll + scrollAmount;
                    // Non tornare all'inizio quando si arriva in fondo
                    if (nextScroll > maxScroll) {
                        return; // Non fare nulla se siamo già alla fine
                    }
                } else {
                    // direction === 'backward'
                    nextScroll = currentScroll - scrollAmount;
                    // Non andare oltre l'inizio
                    if (nextScroll < 0) {
                        return; // Non fare nulla se siamo già all'inizio
                    }
                }
                
                this.carousel.scrollTo({
                    left: nextScroll,
                    behavior: 'smooth'
                });
            }

            updateDebugInfo(status, pointCount, direction = '-') {
                if (!this.debugInfo.classList.contains('active')) return;
                
                document.getElementById('gestureStatus').textContent = status;
                document.getElementById('pointCount').textContent = pointCount;
                
                if (this.touchPoints.length > 1) {
                    const lastAngle = this.touchPoints[this.touchPoints.length - 1].angle;
                    const degrees = Math.round((lastAngle * 180) / Math.PI);
                    document.getElementById('angle').textContent = degrees + '°';
                } else {
                    document.getElementById('angle').textContent = '0°';
                }
                
                document.getElementById('direction').textContent = direction;
            }
        }

        // Inizializza quando il DOM è pronto
        document.addEventListener('DOMContentLoaded', () => {
            const gestureArea = document.getElementById('gestureArea');
            const carousel = document.getElementById('carousel');
            
            new CircularGestureDetector(gestureArea, carousel);
        });
    </script>
</body>
</html>

